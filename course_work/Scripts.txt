-- Table: public.account

-- DROP TABLE IF EXISTS public.account;

CREATE TABLE IF NOT EXISTS public.account
(
    account_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    password character varying(100) COLLATE pg_catalog."default" NOT NULL,
    player_email character varying(50) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT account_pkey PRIMARY KEY (account_id),
    CONSTRAINT player_email_fk_constr FOREIGN KEY (player_email)
        REFERENCES public.player (email) MATCH SIMPLE
        ON UPDATE RESTRICT
        ON DELETE RESTRICT
        NOT VALID
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.account
    OWNER to postgres;

REVOKE ALL ON TABLE public.account FROM admin_role;
REVOKE ALL ON TABLE public.account FROM user_role;
REVOKE ALL ON TABLE public.account FROM visitor_role;

GRANT DELETE, INSERT, SELECT, UPDATE ON TABLE public.account TO admin_role;

GRANT ALL ON TABLE public.account TO manager_role;

GRANT ALL ON TABLE public.account TO postgres;

GRANT UPDATE, INSERT, SELECT ON TABLE public.account TO user_role;

GRANT SELECT, INSERT ON TABLE public.account TO visitor_role;

-- Table: public.admin

-- DROP TABLE IF EXISTS public.admin;

CREATE TABLE IF NOT EXISTS public.admin
(
    access_type character varying COLLATE pg_catalog."default" NOT NULL,
    admin_id integer NOT NULL,
    CONSTRAINT admin_fk FOREIGN KEY (admin_id)
        REFERENCES public.account (account_id) MATCH SIMPLE
        ON UPDATE RESTRICT
        ON DELETE RESTRICT
        NOT VALID,
    CONSTRAINT access_type_check CHECK (access_type::text = ANY (ARRAY['employee'::character varying, 'manager'::character varying]::text[]))
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.admin
    OWNER to postgres;

REVOKE ALL ON TABLE public.admin FROM admin_role;
REVOKE ALL ON TABLE public.admin FROM visitor_role;

GRANT SELECT ON TABLE public.admin TO admin_role;

GRANT ALL ON TABLE public.admin TO manager_role;

GRANT ALL ON TABLE public.admin TO postgres;

GRANT SELECT ON TABLE public.admin TO visitor_role;


-- Table: public.booking

-- DROP TABLE IF EXISTS public.booking;

CREATE TABLE IF NOT EXISTS public.booking
(
    booking_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    group_id integer NOT NULL,
    table_id integer NOT NULL,
    game_id integer NOT NULL,
    payment_id integer NOT NULL,
    date date NOT NULL,
    "time" time without time zone NOT NULL,
    period time without time zone NOT NULL,
    CONSTRAINT booking_pkey PRIMARY KEY (booking_id),
    CONSTRAINT book_team_fk_const FOREIGN KEY (group_id)
        REFERENCES public."group" (group_id) MATCH SIMPLE
        ON UPDATE RESTRICT
        ON DELETE CASCADE,
    CONSTRAINT game_fk_constr FOREIGN KEY (game_id)
        REFERENCES public.game (game_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT payment_fk_constr FOREIGN KEY (payment_id)
        REFERENCES public.payment (payment_id) MATCH SIMPLE
        ON UPDATE RESTRICT
        ON DELETE CASCADE,
    CONSTRAINT table_fk FOREIGN KEY (table_id)
        REFERENCES public."table" (table_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.booking
    OWNER to postgres;

REVOKE ALL ON TABLE public.booking FROM admin_role;
REVOKE ALL ON TABLE public.booking FROM user_role;

GRANT SELECT, UPDATE, INSERT, DELETE ON TABLE public.booking TO admin_role;

GRANT ALL ON TABLE public.booking TO manager_role;

GRANT ALL ON TABLE public.booking TO postgres;

GRANT INSERT, SELECT ON TABLE public.booking TO user_role;
-- Index: idx_booking_date

-- DROP INDEX IF EXISTS public.idx_booking_date;

CREATE INDEX IF NOT EXISTS idx_booking_date
    ON public.booking USING btree
    (date ASC NULLS LAST)
    TABLESPACE pg_default;
-- Index: idx_booking_group_id

-- DROP INDEX IF EXISTS public.idx_booking_group_id;

CREATE INDEX IF NOT EXISTS idx_booking_group_id
    ON public.booking USING btree
    (group_id ASC NULLS LAST)
    TABLESPACE pg_default;

-- Trigger: trg_check_booking_conflicts

-- DROP TRIGGER IF EXISTS trg_check_booking_conflicts ON public.booking;

CREATE OR REPLACE TRIGGER trg_check_booking_conflicts
    BEFORE INSERT
    ON public.booking
    FOR EACH ROW
    EXECUTE FUNCTION public.check_booking_conflicts();

-- Trigger: trg_create_payment_before_booking

-- DROP TRIGGER IF EXISTS trg_create_payment_before_booking ON public.booking;

CREATE OR REPLACE TRIGGER trg_create_payment_before_booking
    BEFORE INSERT
    ON public.booking
    FOR EACH ROW
    EXECUTE FUNCTION public.create_payment_before_booking();

-- Table: public.game

-- DROP TABLE IF EXISTS public.game;

CREATE TABLE IF NOT EXISTS public.game
(
    game_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    game_name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    rules text COLLATE pg_catalog."default" NOT NULL,
    status character varying COLLATE pg_catalog."default" NOT NULL,
    players character varying(20) COLLATE pg_catalog."default" NOT NULL,
    goal character varying COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT game_pkey PRIMARY KEY (game_id),
    CONSTRAINT status_check CHECK (status::text = ANY (ARRAY['new'::character varying, 'good'::character varying, 'used'::character varying, 'unusable'::character varying]::text[]))
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.game
    OWNER to postgres;

REVOKE ALL ON TABLE public.game FROM admin_role;
REVOKE ALL ON TABLE public.game FROM user_role;
REVOKE ALL ON TABLE public.game FROM visitor_role;

GRANT SELECT ON TABLE public.game TO admin_role;

GRANT ALL ON TABLE public.game TO manager_role;

GRANT ALL ON TABLE public.game TO postgres;

GRANT SELECT ON TABLE public.game TO user_role;

GRANT SELECT ON TABLE public.game TO visitor_role;

-- Table: public.group

-- DROP TABLE IF EXISTS public."group";

CREATE TABLE IF NOT EXISTS public."group"
(
    group_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    players_amount integer NOT NULL,
    is_full boolean NOT NULL,
    CONSTRAINT team_pkey PRIMARY KEY (group_id),
    CONSTRAINT players_amount_check CHECK (players_amount >= 2 AND players_amount <= 20)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public."group"
    OWNER to postgres;

REVOKE ALL ON TABLE public."group" FROM admin_role;
REVOKE ALL ON TABLE public."group" FROM user_role;
REVOKE ALL ON TABLE public."group" FROM visitor_role;

GRANT DELETE, UPDATE, SELECT, INSERT ON TABLE public."group" TO admin_role;

GRANT ALL ON TABLE public."group" TO manager_role;

GRANT ALL ON TABLE public."group" TO postgres;

GRANT SELECT, UPDATE, INSERT ON TABLE public."group" TO user_role;

GRANT SELECT ON TABLE public."group" TO visitor_role;

-- Table: public.members_list

-- DROP TABLE IF EXISTS public.members_list;

CREATE TABLE IF NOT EXISTS public.members_list
(
    list_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    group_id integer NOT NULL,
    email character varying(50) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT members_team_id FOREIGN KEY (group_id)
        REFERENCES public."group" (group_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
        NOT VALID,
    CONSTRAINT player_fk_member FOREIGN KEY (email)
        REFERENCES public.player (email) MATCH SIMPLE
        ON UPDATE RESTRICT
        ON DELETE RESTRICT
        NOT VALID
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.members_list
    OWNER to postgres;

REVOKE ALL ON TABLE public.members_list FROM admin_role;
REVOKE ALL ON TABLE public.members_list FROM user_role;
REVOKE ALL ON TABLE public.members_list FROM visitor_role;

GRANT UPDATE, SELECT, DELETE, INSERT ON TABLE public.members_list TO admin_role;

GRANT ALL ON TABLE public.members_list TO manager_role;

GRANT ALL ON TABLE public.members_list TO postgres;

GRANT SELECT, INSERT ON TABLE public.members_list TO user_role;

GRANT SELECT ON TABLE public.members_list TO visitor_role;

-- Trigger: trigger_update_players_amount

-- DROP TRIGGER IF EXISTS trigger_update_players_amount ON public.members_list;

CREATE OR REPLACE TRIGGER trigger_update_players_amount
    AFTER INSERT
    ON public.members_list
    FOR EACH ROW
    EXECUTE FUNCTION public.update_players_amount();

-- Table: public.monopoly_championship

-- DROP TABLE IF EXISTS public.monopoly_championship;

CREATE TABLE IF NOT EXISTS public.monopoly_championship
(
    play_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    group_id integer NOT NULL,
    winner_id character varying(50) COLLATE pg_catalog."default" NOT NULL,
    game_id integer NOT NULL,
    date date NOT NULL,
    "time" time without time zone NOT NULL,
    stage character varying COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT monopoly_championship_pkey PRIMARY KEY (play_id),
    CONSTRAINT champ_game_fk FOREIGN KEY (game_id)
        REFERENCES public.game (game_id) MATCH SIMPLE
        ON UPDATE RESTRICT
        ON DELETE RESTRICT,
    CONSTRAINT champ_team_fk FOREIGN KEY (group_id)
        REFERENCES public."group" (group_id) MATCH SIMPLE
        ON UPDATE RESTRICT
        ON DELETE RESTRICT,
    CONSTRAINT winner_fk FOREIGN KEY (winner_id)
        REFERENCES public.player (email) MATCH SIMPLE
        ON UPDATE RESTRICT
        ON DELETE RESTRICT
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.monopoly_championship
    OWNER to postgres;

REVOKE ALL ON TABLE public.monopoly_championship FROM admin_role;
REVOKE ALL ON TABLE public.monopoly_championship FROM visitor_role;

GRANT SELECT ON TABLE public.monopoly_championship TO admin_role;

GRANT ALL ON TABLE public.monopoly_championship TO manager_role;

GRANT ALL ON TABLE public.monopoly_championship TO postgres;

GRANT SELECT ON TABLE public.monopoly_championship TO visitor_role;
-- Index: idx_champ_date

-- DROP INDEX IF EXISTS public.idx_champ_date;

CREATE INDEX IF NOT EXISTS idx_champ_date
    ON public.monopoly_championship USING btree
    (date ASC NULLS LAST)
    TABLESPACE pg_default;
-- Index: idx_champ_group_id

-- DROP INDEX IF EXISTS public.idx_champ_group_id;

CREATE INDEX IF NOT EXISTS idx_champ_group_id
    ON public.monopoly_championship USING btree
    (group_id ASC NULLS LAST)
    TABLESPACE pg_default;

-- Table: public.payment

-- DROP TABLE IF EXISTS public.payment;

CREATE TABLE IF NOT EXISTS public.payment
(
    payment_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    status character varying COLLATE pg_catalog."default",
    amount integer,
    card_or_cash boolean,
    CONSTRAINT payment_pkey PRIMARY KEY (payment_id),
    CONSTRAINT payment_status_check CHECK (status::text = ANY (ARRAY['booked'::character varying, 'waiting'::character varying, 'successful'::character varying, 'declined'::character varying, 'unbooked'::character varying]::text[]))
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.payment
    OWNER to postgres;

REVOKE ALL ON TABLE public.payment FROM admin_role;
REVOKE ALL ON TABLE public.payment FROM user_role;

GRANT UPDATE, SELECT, DELETE, INSERT ON TABLE public.payment TO admin_role;

GRANT ALL ON TABLE public.payment TO manager_role;

GRANT ALL ON TABLE public.payment TO postgres;

GRANT INSERT, SELECT ON TABLE public.payment TO user_role;


-- Table: public.player

-- DROP TABLE IF EXISTS public.player;

CREATE TABLE IF NOT EXISTS public.player
(
    email character varying(50) COLLATE pg_catalog."default" NOT NULL,
    full_name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    phone integer NOT NULL,
    CONSTRAINT player_pkey PRIMARY KEY (email),
    CONSTRAINT email_unique UNIQUE (email)
        INCLUDE(email)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.player
    OWNER to postgres;

REVOKE ALL ON TABLE public.player FROM admin_role;
REVOKE ALL ON TABLE public.player FROM user_role;
REVOKE ALL ON TABLE public.player FROM visitor_role;

GRANT DELETE, INSERT, SELECT, UPDATE ON TABLE public.player TO admin_role;

GRANT ALL ON TABLE public.player TO manager_role;

GRANT ALL ON TABLE public.player TO postgres;

GRANT UPDATE, INSERT, SELECT ON TABLE public.player TO user_role;

GRANT SELECT, INSERT ON TABLE public.player TO visitor_role;

-- Table: public.table

-- DROP TABLE IF EXISTS public."table";

CREATE TABLE IF NOT EXISTS public."table"
(
    table_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    status boolean NOT NULL,
    state character varying COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT table_pkey PRIMARY KEY (table_id),
    CONSTRAINT state_check CHECK (state::text = ANY (ARRAY['clean'::character varying, 'dirty'::character varying, 'unusable'::character varying]::text[]))
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public."table"
    OWNER to postgres;

REVOKE ALL ON TABLE public."table" FROM admin_role;
REVOKE ALL ON TABLE public."table" FROM user_role;

GRANT SELECT ON TABLE public."table" TO admin_role;

GRANT ALL ON TABLE public."table" TO manager_role;

GRANT ALL ON TABLE public."table" TO postgres;

GRANT SELECT ON TABLE public."table" TO user_role;



-------------------------------------
-------------------------------------


CREATE INDEX idx_booking_date ON public.booking(date);
CREATE INDEX idx_booking_group_id ON public.booking(group_id);

CREATE INDEX idx_champ_date ON public.monopoly_championship(date);
CREATE INDEX idx_champ_group_id ON public.monopoly_championship(group_id);


-------------------------------------
-------------------------------------

-- FUNCTION: public.check_booking_conflicts()

-- DROP FUNCTION IF EXISTS public.check_booking_conflicts();

CREATE OR REPLACE FUNCTION public.check_booking_conflicts()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
DECLARE
    table_conflict INTEGER;
    game_conflict INTEGER;
BEGIN
    -- Перевірка конфлікту по столу
    SELECT COUNT(*) INTO table_conflict
    FROM public.booking
    WHERE
        table_id = NEW.table_id AND
        date = NEW.date AND
        (
            (time < NEW.time + NEW.period::INTERVAL) AND
            (time + period::INTERVAL > NEW.time)
        );

    IF table_conflict > 0 THEN
        RAISE EXCEPTION 'Table % is already booked for this time period.', NEW.table_id;
    END IF;

    -- Перевірка конфлікту по грі
    SELECT COUNT(*) INTO game_conflict
    FROM public.booking
    WHERE
        game_id = NEW.game_id AND
        date = NEW.date AND
        (
            (time < NEW.time + NEW.period::INTERVAL) AND
            (time + period::INTERVAL > NEW.time)
        );

    IF game_conflict > 0 THEN
        RAISE EXCEPTION 'Game % is already booked for this time period.', NEW.game_id;
    END IF;

    RETURN NEW;
END;
$BODY$;

ALTER FUNCTION public.check_booking_conflicts()
    OWNER TO postgres;


CREATE OR REPLACE TRIGGER trg_check_booking_conflicts
    BEFORE INSERT
    ON public.booking
    FOR EACH ROW
    EXECUTE FUNCTION public.check_booking_conflicts();

-------------------------------------

-- FUNCTION: public.create_payment_before_booking()

DROP FUNCTION IF EXISTS public.create_payment_before_booking();

CREATE OR REPLACE FUNCTION public.create_payment_before_booking()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
DECLARE
    player_count INTEGER;
    period_hours NUMERIC;
    new_payment_id INTEGER;
BEGIN
    -- Get number of players in the group
    SELECT players_amount INTO player_count
    FROM public.group
    WHERE group_id = NEW.group_id;

    -- Convert time period to total hours
    SELECT EXTRACT(HOUR FROM NEW.period) + EXTRACT(MINUTE FROM NEW.period) / 60
    INTO period_hours;

    -- Insert payment and retrieve payment_id
    INSERT INTO public.payment (status, card_or_cash, amount)
    VALUES ('booked', true, CEIL(5 * player_count * period_hours))
    RETURNING payment_id INTO new_payment_id;

    -- Assign the generated payment_id to the booking row
    NEW.payment_id := new_payment_id;

    RETURN NEW;
END;
$BODY$;

ALTER FUNCTION public.create_payment_before_booking()
    OWNER TO postgres;


-- Trigger: trg_create_payment_before_booking

-- DROP TRIGGER IF EXISTS trg_create_payment_before_booking ON public.booking;

CREATE OR REPLACE TRIGGER trg_create_payment_before_booking
    BEFORE INSERT
    ON public.booking
    FOR EACH ROW
    EXECUTE FUNCTION public.create_payment_before_booking();

---------------------------------------

-- FUNCTION: public.update_players_amount()

-- DROP FUNCTION IF EXISTS public.update_players_amount();

CREATE OR REPLACE FUNCTION public.update_players_amount()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
BEGIN
    -- Only update if there are more than one member in the group
    IF (
        SELECT COUNT(DISTINCT email)
        FROM public.members_list
        WHERE group_id = NEW.group_id
    ) > 2 THEN
        UPDATE public."group"
        SET players_amount = (
            SELECT COUNT(DISTINCT email)
            FROM public.members_list
            WHERE group_id = NEW.group_id
        )
        WHERE group_id = NEW.group_id;
    END IF;

    RETURN NEW;
END;
$BODY$;

ALTER FUNCTION public.update_players_amount()
    OWNER TO postgres;

CREATE TRIGGER trigger_update_players_amount
AFTER INSERT ON public.members_list
FOR EACH ROW
EXECUTE FUNCTION update_players_amount();


--------------------------------------------
--------------------------------------------




CREATE ROLE visitor_role;
CREATE ROLE user_role;
CREATE ROLE admin_role;
CREATE ROLE manager_role;


GRANT SELECT ON public.game, public.monopoly_championship, public.admin TO visitor_role;
GRANT SELECT, INSERT ON public.account, public.player TO visitor_role;

GRANT SELECT, INSERT ON public.booking, public.account, public.player, public.members_list, public.table, public,payment, public."group" TO user_role;

GRANT SELECT ON ALL TABLES IN SCHEMA public TO admin_role;
GRANT INSERT, UPDATE, DELETE ON 
  public.booking,
  public.account,
  public.player,
  public.members_list,
  public.payment,
  public."group"
TO admin_role;

GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO manager_role;


CREATE ROLE visitor_user WITH LOGIN PASSWORD '1111';
GRANT visitor_role TO visitor_user;

-- User role user
CREATE ROLE user1 WITH LOGIN PASSWORD '11111';
GRANT user_role TO user1;

-- Admin user
CREATE ROLE admin1 WITH LOGIN PASSWORD '111111';
GRANT admin_role TO admin1;

-- Manager user
CREATE ROLE manager1 WITH LOGIN PASSWORD '1111111';
GRANT manager_role TO manager1;



